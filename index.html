<!DOCTYPE html>
<html>
<head>
    <title>FlameGame</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #f5f5f5;
            min-height: 100vh;
        }
        #gameContainer {
            border: 2px solid #333;
            width: 95vw;
            height: 80vh;
            overflow: hidden;
            background: white;
            position: relative;
        }
        .controls {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 95vw;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 95vw;
        }
        .input-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #urlInput {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #ff5722;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            white-space: nowrap;
        }
        button:hover {
            background: #f4511e;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        h1 {
            color: #ff5722;
            font-size: 2em;
            margin: 10px 0;
        }
        #stats {
            font-size: 1.2em;
            margin: 5px 0;
            font-weight: bold;
        }
        #stats span {
            margin: 0 10px;
        }
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 1000;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            margin: 5px;
            font-size: 20px;
            touch-action: manipulation;
        }
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            .input-section {
                flex-wrap: wrap;
            }
            #urlInput {
                width: 100%;
            }
            h1 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <h1>FlameGame</h1>
    
    <div class="input-group">
        <div class="input-section">
            <label>File:</label>
            <input type="file" id="fileInput" accept=".svg">
        </div>
        <div class="input-section">
            <label>URL:</label>
            <input type="text" id="urlInput" placeholder="Enter SVG URL">
            <button id="loadUrlButton">Load</button>
        </div>
    </div>

    <div id="stats">
        <span id="timer">Time: 0.0s</span>
        <span id="bestTime">Best: --</span>
    </div>
    <div id="gameContainer"></div>
    <button id="startButton" disabled>Start Game</button>
    
    <div id="mobileControls">
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="jumpBtn">↑</button>
        <button class="control-btn" id="rightBtn">→</button>
        <button class="control-btn" id="attackBtn">X</button>
    </div>

    <div class="controls">
        <h3>Controls:</h3>
        <ul>
            <li>Desktop: Arrow Keys to Move, Space to Jump, X to Attack</li>
            <li>Mobile: On-screen buttons</li>
        </ul>
    </div>
    <script>

const game = {
    player: {
        x: 100,
        y: 100,
        width: 30,
        height: 50,
        velX: 0,
        velY: 0,
        isJumping: false,
        isAttacking: false,
        facingRight: true,
        attackDirection: 'right', // 'right', 'left', or 'up'
        attackTimeout: null
    },
    blocks: [],
    keys: {},
    isRunning: false,
    startTime: 0,
    currentTime: 0,
    bestTime: localStorage.getItem('bestTime') || Infinity,
    ctx: null,
    scale: 1,
    heightScale: 1,
};

const GRAVITY = 0.5;
const JUMP_FORCE = -16;
const MOVE_SPEED = 6;
const ATTACK_DURATION = 200;

// Initialize game
function init() {
    const container = document.getElementById('gameContainer');
    container.innerHTML = '';
    
    const canvas = document.createElement('canvas');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    container.appendChild(canvas);
    
    game.ctx = canvas.getContext('2d');
    setupEventListeners();
    
    // Load default flame graph
    loadSVG("./default.svg", true);
    
    return game.ctx;
}

function loadSVGContent(svgContent) {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
    const rects = Array.from(svgDoc.querySelectorAll('rect'));
    
    // Skip rects with width="100%"
    const validRects = rects.filter(rect => rect.getAttribute('width') !== '100%');
    
    const containerWidth = game.ctx.canvas.width;
    const containerHeight = game.ctx.canvas.height;
    
    // Find the boundaries of the SVG content
    let maxRight = 0;
    let maxBottom = 0;
    validRects.forEach(rect => {
        const right = parseFloat(rect.getAttribute('x')) + parseFloat(rect.getAttribute('width'));
        const bottom = parseFloat(rect.getAttribute('y')) + parseFloat(rect.getAttribute('height'));
        maxRight = Math.max(maxRight, right);
        maxBottom = Math.max(maxBottom, bottom);
    });
    console.log(maxRight, maxBottom);
    console.log(validRects)
    
    // Always scale to full width, then adjust height proportionally
    game.scale = containerWidth / maxRight;
    game.heightScale = containerHeight / maxBottom;
    
    // Scale and store blocks
    game.blocks = validRects.map(rect => {
        const x = parseFloat(rect.getAttribute('x'));
        const y = parseFloat(rect.getAttribute('y'));
        const width = parseFloat(rect.getAttribute('width'));
        const height = parseFloat(rect.getAttribute('height'));
        
        return {
            x: x * game.scale,
            y: y * game.heightScale,
            width: width * game.scale,
            height: height * game.heightScale,
            fill: rect.getAttribute('fill')
        };
    });
   
    document.getElementById('startButton').disabled = false;
    render();
    startGame();
}


// Load SVG from file or URL
async function loadSVG(source, isUrl = false) {
    try {
        let svgText;
        if (isUrl) {
            const response = await fetch(source);
            svgText = await response.text();
        } else {
            svgText = await source.text();
        }
        loadSVGContent(svgText);
    } catch (error) {
        console.error('Error loading SVG:', error);
    }
}

// Event Listeners
function setupEventListeners() {
    window.addEventListener('keydown', e => {
        game.keys[e.key] = true;
        if (e.key === ' ' || ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', e => {
        game.keys[e.key] = false;
    });
    
    document.getElementById('fileInput').addEventListener('change', e => {
        if (e.target.files[0]) {
            loadSVG(e.target.files[0]);
        }
    });
    
    document.getElementById('loadUrlButton').addEventListener('click', () => {
        const url = document.getElementById('urlInput').value;
        if (url) {
            loadSVG(url, true);
        }
    });
    
    document.getElementById('startButton').addEventListener('click', startGame);
}

// Game loop
function gameLoop() {
    if (!game.isRunning) return;

    updatePlayer();
    checkCollisions();
    render();
    updateTimer();
    
    requestAnimationFrame(gameLoop);
}

// Update player position and state
function updatePlayer() {
    // Horizontal movement
    console.log("up", game.keys);
    if (game.keys['ArrowLeft']) {
        game.player.velX = -MOVE_SPEED;
        game.player.facingRight = false;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'left';
        }
    } else if (game.keys['ArrowRight']) {
        game.player.velX = MOVE_SPEED;
        game.player.facingRight = true;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'right';
        }
    } else if (game.keys['ArrowUp']) {
        game.player.attackDirection = 'up';
    }
    else game.player.velX = 0;
    console.log("attackDirection", game.player.attackDirection);

    // Jumping
    if (game.keys[' '] && !game.player.isJumping) {
        game.player.velY = JUMP_FORCE;
        game.player.isJumping = true;
    }

    // Attacking
    if (game.keys['x'] && !game.player.isAttacking) {
        game.player.isAttacking = true;
        attackWithMachete();
        setTimeout(() => {
            game.player.isAttacking = false;
        }, ATTACK_DURATION);
    }

    // Apply physics
    game.player.velY += GRAVITY;
    game.player.x += game.player.velX;
    game.player.y += game.player.velY;

    // Keep player in bounds
    if (game.player.x < 0) game.player.x = 0;
    if (game.player.x + game.player.width > game.ctx.canvas.width) {
        game.player.x = game.ctx.canvas.width - game.player.width;
    }
}

function checkCollisions() {
    game.player.isJumping = true;
    
    // Check floor collision first
    const floorY = game.ctx.canvas.height - game.player.height;
    if (game.player.y > floorY) {
        game.player.y = floorY;
        game.player.velY = 0;
        game.player.isJumping = false;
    }
    
    // Check block collisions
    for (const block of game.blocks) {
        if (game.player.x < block.x + block.width &&
            game.player.x + game.player.width > block.x &&
            game.player.y + game.player.height > block.y &&
            game.player.y < block.y + block.height) {
            
            // Ground collision
            if (game.player.velY > 0 && game.player.y + game.player.height - game.player.velY <= block.y) {
                game.player.y = block.y - game.player.height;
                game.player.velY = 0;
                game.player.isJumping = false;
            }
            // Ceiling collision
            else if (game.player.velY < 0 && game.player.y - game.player.velY >= block.y + block.height) {
                game.player.y = block.y + block.height;
                game.player.velY = 0;
            }
            // Wall collision
            else if (game.player.velX !== 0) {
                if (game.player.velX > 0) {
                    game.player.x = block.x - game.player.width;
                } else {
                    game.player.x = block.x + block.width;
                }
            }
        }
    }
}

function attackWithMachete() {
    const attackRange = 50;
    let attackBox;

    switch (game.player.attackDirection) {
        case 'up':
            attackBox = {
                x: game.player.x,
                y: game.player.y - attackRange,
                width: game.player.width,
                height: attackRange
            };
            break;
        case 'right':
            attackBox = {
                x: game.player.x + game.player.width,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
        case 'left':
            attackBox = {
                x: game.player.x - attackRange,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
    }

    game.blocks = game.blocks.filter(block => {
        return !(attackBox.x < block.x + block.width &&
                attackBox.x + attackBox.width > block.x &&
                attackBox.y < block.y + block.height &&
                attackBox.y + attackBox.height > block.y);
    });
}

const playerSpriteSVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">
    <!-- Head (Profile View) -->
    <rect x="14" y="5" width="20" height="20" rx="4" fill="#f4c7a3" stroke="#000" stroke-width="1.5"/>
    <!-- Hair -->
    <path d="M14 5 Q25 -5 34 8 Q34 10 28 8 Q24 9 14 10 Z" fill="#6b4423" stroke="#000" stroke-width="1.5"/>
    <!-- Facial Features -->
    <!-- Eye -->
    <rect x="28" y="12" width="3" height="3" fill="#000"/>
    <!-- Eyebrow -->
    <path d="M28 10 Q30 8 32 10" stroke="#000" stroke-width="1.5" fill="none"/>
    <!-- Nose -->
    <path d="M32 14 Q35 15 32 17" stroke="#000" stroke-width="1.5" fill="none"/>
    <!-- Mouth -->
    <path d="M30 18 Q33 20 32 22" stroke="#000" stroke-width="1.5" fill="none"/>
    <!-- Chin -->
    <path d="M32 22 Q34 24 30 25" stroke="#000" stroke-width="1" fill="none"/>
    <!-- Body (Sturdy and Bulky) -->
    <rect x="18" y="25" width="14" height="20" fill="#3a79ff" stroke="#000" stroke-width="1.5"/>
    <!-- Chest Definition -->
    <path d="M19 26 Q25 22 31 26" fill="#f4c7a3" stroke="#000" stroke-width="1.5"/>
    <!-- Abs -->
    <path d="M21 28 L21 40 M27 28 L27 40" stroke="#000" stroke-width="1"/>
    <!-- Belt -->
    <rect x="18" y="40" width="14" height="2" fill="#222" stroke="#000" stroke-width="1.5"/>
    <!-- Legs -->
    <rect x="20" y="42" width="5" height="8" fill="#555" stroke="#000" stroke-width="1.5"/>
    <rect x="25" y="42" width="5" height="8" fill="#555" stroke="#000" stroke-width="1.5"/>
    <!-- Boots -->
    <rect x="20" y="48" width="5" height="3" fill="#222" stroke="#000" stroke-width="1.5"/>
    <rect x="25" y="48" width="5" height="3" fill="#222" stroke="#000" stroke-width="1.5"/>
    <!-- Arms -->
    <!-- Front Arm -->
    <rect x="31" y="26" width="6" height="10" fill="#f4c7a3" stroke="#000" stroke-width="1.5"/>
    <rect x="31" y="34" width="6" height="4" fill="#555" stroke="#000" stroke-width="1.5"/>
    <!-- Back Arm -->
    <path d="M18 26 Q15 30 18 36" fill="#f4c7a3" stroke="#000" stroke-width="1.5"/>
    <path d="M16 34 Q16 36 18 38" fill="#555" stroke="#000" stroke-width="1.5"/>
</svg>
`;

const playerSprite = new Image();
playerSprite.src = 'data:image/svg+xml;base64,' + btoa(playerSpriteSVG);

playerSprite.onload = function () {
    game.startRendering();
};

const macheteSlashSVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 200">
  <!-- Motion blur/speed lines -->
  <path d="M50 100 C150 30, 250 10, 360 70" 
        stroke="#ff0000" 
        stroke-width="6" 
        fill="none" 
        stroke-dasharray="10,20"/>
  <path d="M50 110 C150 40, 250 20, 370 80" 
        stroke="#ff9900" 
        stroke-width="4" 
        fill="none" 
        stroke-dasharray="12,18"/>
  <path d="M50 120 C150 50, 250 30, 380 90" 
        stroke="#ffff00" 
        stroke-width="2" 
        fill="none" 
        stroke-dasharray="6,12"/>
  
  <!-- Machete blade -->
  <path d="M290 80 L360 70 L345 120 L275 105 Z" 
        fill="#cfcfcf" 
        stroke="#000000" 
        stroke-width="3"/>
  
  <!-- Handle -->
  <path d="M260 100 L290 85 L280 105 L250 120 Z" 
        fill="#884c24" 
        stroke="#000000" 
        stroke-width="3"/>
  
  <!-- Bold Impact Lines -->
  <path d="M350 85 L380 60" stroke="#000000" stroke-width="4"/>
  <path d="M355 80 L385 55" stroke="#000000" stroke-width="3"/>
  <path d="M360 75 L390 50" stroke="#000000" stroke-width="2"/>
  
  <!-- Impact Burst (Comic Style) -->
  <path d="M370 65 L380 50 L390 65 L380 80 Z" 
        fill="#ff0000" 
        stroke="#000000" 
        stroke-width="2"/>
  <path d="M375 60 L385 55 L395 60 L385 65 Z" 
        fill="#ffff00" 
        stroke="#000000" 
        stroke-width="1.5"/>
  
  <!-- Speed Effect (Dynamic Arcs) -->
  <circle cx="380" cy="60" r="6" fill="#ffffff" stroke="#000000" stroke-width="2"/>
  <circle cx="390" cy="55" r="4" fill="#ffffff" stroke="#000000" stroke-width="1.5"/>
</svg>
`;

// Convert SVG to Image for Canvas
const macheteSlashImage = new Image();
macheteSlashImage.src = 'data:image/svg+xml;base64,' + btoa(macheteSlashSVG);

macheteSlashImage.onload = function () {
    game.startRendering();
};

function render() {
    const ctx = game.ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw floor
    ctx.fillStyle = '#666';
    ctx.fillRect(0, ctx.canvas.height - 10, ctx.canvas.width, 10);

    // Draw blocks
    game.blocks.forEach(block => {
        ctx.fillStyle = block.fill || '#ff7f00';
        ctx.fillRect(block.x, block.y, block.width, block.height);

        // Draw block borders
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.strokeRect(block.x, block.y, block.width, block.height);
    });

    // Draw player sprite
    ctx.save();
    if (!game.player.facingRight) {
        ctx.translate(game.player.x + game.player.width, game.player.y);
        ctx.scale(-1, 1);
        ctx.drawImage(playerSprite, 0, 0, game.player.width, game.player.height);
    } else {
        ctx.drawImage(playerSprite, game.player.x, game.player.y, game.player.width, game.player.height);
    }
    ctx.restore();

    // Draw attack animation if attacking
    if (game.player.isAttacking) {
        ctx.save();

        const tileSize = 50; // Tile size
        let slashX = game.player.x;
        let slashY = game.player.y;
        let rotation = 0;

        // Determine slash position and rotation
        switch (game.player.attackDirection) {
            case 'right':
                slashX += game.player.width; // Slash to the right of the player
                rotation = 0;
                break;
            case 'left':
                slashX -= tileSize; // Slash to the left of the player
                rotation = Math.PI; // Rotate to the left
                break;
            case 'up':
                slashY -= tileSize; // Slash above the player
                rotation = -Math.PI / 2; // Rotate upward
                break;
        }

        // Move to slash position and rotate
        ctx.translate(slashX + tileSize / 2, slashY + tileSize / 2);
        ctx.rotate(rotation);

        // Draw the machete slash
        ctx.drawImage(macheteSlashImage, -tileSize / 2, -tileSize / 2, tileSize, tileSize / 3);

        ctx.restore();
    }
}

// Update timer
function updateTimer() {
    if (game.isRunning) {
        game.currentTime = (Date.now() - game.startTime) / 1000;
        document.getElementById('timer').textContent = `Time: ${game.currentTime.toFixed(1)}s`;
    }
}

// Start game
function startGame() {
    game.isRunning = true;
    game.startTime = Date.now();

    // Reset player position
    game.player.x = 50;
    game.player.y = 0;
    game.player.velX = 0;
    game.player.velY = 0;

    document.getElementById('startButton').textContent = 'Reset Game';
    document.getElementById('startButton').onclick = resetGame;
    gameLoop();
}

// Reset game
function resetGame() {
    game.isRunning = false;
    if (game.currentTime < game.bestTime) {
        game.bestTime = game.currentTime;
        localStorage.setItem('bestTime', game.bestTime);
        document.getElementById('bestTime').textContent = `Best: ${game.bestTime.toFixed(1)}s`;
    }
    init();
    document.getElementById('startButton').textContent = 'Start Game';
    document.getElementById('startButton').onclick = startGame;
}

// Initialize the game when the page loads
window.addEventListener('load', () => {
    init();
    if (localStorage.getItem('bestTime')) {
        document.getElementById('bestTime').textContent = 
            `Best: ${parseFloat(localStorage.getItem('bestTime')).toFixed(1)}s`;
    }
});
    </script>
</body>
</html>

