<!DOCTYPE html>
<html>
<head>
    <title>FlameGame</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        #gameContainer {
            border: 2px solid #333;
            margin: 20px 0;
            width: 1024px;
            height: 768px;
            overflow: hidden;
            background: white;
            position: relative;
        }
        .controls {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .input-group {
            margin: 10px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #urlInput {
            width: 300px;
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #ff5722;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover {
            background: #f4511e;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        h1 {
            color: #ff5722;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        #stats {
            font-size: 1.2em;
            margin: 10px 0;
            font-weight: bold;
        }
        #stats span {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <h1>FlameGame</h1>
    
    <div class="input-group">
        <h3>Load Your Level</h3>
        <div>
            <h4>Option 1: From File</h4>
            <input type="file" id="fileInput" accept=".svg">
        </div>
        <div>
            <h4>Option 2: From URL</h4>
            <input type="text" id="urlInput" placeholder="Enter SVG URL">
            <button id="loadUrlButton">Load URL</button>
        </div>
    </div>

    <div id="stats">
        <span id="timer">Time: 0.0s</span>
        <span id="bestTime">Best: --</span>
    </div>
    <div id="gameContainer"></div>
    <button id="startButton" disabled>Start Game</button>
    <div class="controls">
        <h3>Controls:</h3>
        <ul>
            <li>Left/Right Arrow: Move</li>
            <li>Space: Jump</li>
            <li>X: Attack with machete</li>
        </ul>
    </div>
    <script>

const game = {
    player: {
        x: 100,
        y: 100,
        width: 30,
        height: 50,
        velX: 0,
        velY: 0,
        isJumping: false,
        isAttacking: false,
        facingRight: true,
        attackDirection: 'right', // 'right', 'left', or 'up'
        attackTimeout: null
    },
    blocks: [],
    keys: {},
    isRunning: false,
    startTime: 0,
    currentTime: 0,
    bestTime: localStorage.getItem('bestTime') || Infinity,
    ctx: null,
    scale: 1,
    heightScale: 1,
};

const GRAVITY = 0.5;
const JUMP_FORCE = -10;
const MOVE_SPEED = 5;
const ATTACK_DURATION = 200;

// Default flame graph SVG
const defaultSVG = `
<svg width="1200" height="300">
    <rect x="10" y="250" width="1180" height="50" fill="#ff7f00"/>
    <rect x="100" y="200" width="400" height="50" fill="#ff9f00"/>
    <rect x="600" y="200" width="300" height="50" fill="#ffbf00"/>
    <rect x="150" y="150" width="200" height="50" fill="#ffdf00"/>
    <rect x="650" y="150" width="150" height="50" fill="#ffff00"/>
</svg>`;

// Initialize game
function init() {
    const container = document.getElementById('gameContainer');
    container.innerHTML = '';
    
    const canvas = document.createElement('canvas');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    container.appendChild(canvas);
    
    game.ctx = canvas.getContext('2d');
    setupEventListeners();
    
    // Load default flame graph
    loadSVGContent(defaultSVG);
    
    return game.ctx;
}

function loadSVGContent(svgContent) {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
    const rects = Array.from(svgDoc.querySelectorAll('rect'));
    
    // Skip rects with width="100%"
    const validRects = rects.filter(rect => rect.getAttribute('width') !== '100%');
    
    const containerWidth = game.ctx.canvas.width;
    const containerHeight = game.ctx.canvas.height;
    
    // Find the boundaries of the SVG content
    let maxRight = 0;
    let maxBottom = 0;
    validRects.forEach(rect => {
        const right = parseFloat(rect.getAttribute('x')) + parseFloat(rect.getAttribute('width'));
        const bottom = parseFloat(rect.getAttribute('y')) + parseFloat(rect.getAttribute('height'));
        maxRight = Math.max(maxRight, right);
        maxBottom = Math.max(maxBottom, bottom);
    });
    console.log(maxRight, maxBottom);
    console.log(validRects)
    
    // Always scale to full width, then adjust height proportionally
    game.scale = containerWidth / maxRight;
    game.heightScale = containerHeight / maxBottom;
    
    // Scale and store blocks
    game.blocks = validRects.map(rect => {
        const x = parseFloat(rect.getAttribute('x'));
        const y = parseFloat(rect.getAttribute('y'));
        const width = parseFloat(rect.getAttribute('width'));
        const height = parseFloat(rect.getAttribute('height'));
        
        return {
            x: x * game.scale,
            y: y * game.heightScale,
            width: width * game.scale,
            height: height * game.heightScale,
            fill: rect.getAttribute('fill')
        };
    });

    // Reset player position
    game.player.x = 50;
    game.player.y = 0;
    game.player.velX = 0;
    game.player.velY = 0;
    
    document.getElementById('startButton').disabled = false;
    render();
}


// Load SVG from file or URL
async function loadSVG(source, isUrl = false) {
    try {
        let svgText;
        if (isUrl) {
            const response = await fetch(source);
            svgText = await response.text();
        } else {
            svgText = await source.text();
        }
        loadSVGContent(svgText);
    } catch (error) {
        console.error('Error loading SVG:', error);
    }
}

// Event Listeners
function setupEventListeners() {
    window.addEventListener('keydown', e => {
        game.keys[e.key] = true;
        if (e.key === ' ' || ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', e => {
        game.keys[e.key] = false;
    });
    
    document.getElementById('fileInput').addEventListener('change', e => {
        if (e.target.files[0]) {
            loadSVG(e.target.files[0]);
        }
    });
    
    document.getElementById('loadUrlButton').addEventListener('click', () => {
        const url = document.getElementById('urlInput').value;
        if (url) {
            loadSVG(url, true);
        }
    });
    
    document.getElementById('startButton').addEventListener('click', startGame);
}

// Game loop
function gameLoop() {
    if (!game.isRunning) return;

    updatePlayer();
    checkCollisions();
    render();
    updateTimer();
    
    requestAnimationFrame(gameLoop);
}

// Update player position and state
function updatePlayer() {
    // Horizontal movement
    if (game.keys['ArrowLeft']) {
        game.player.velX = -MOVE_SPEED;
        game.player.facingRight = false;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'left';
        }
    }
    else if (game.keys['ArrowRight']) {
        game.player.velX = MOVE_SPEED;
        game.player.facingRight = true;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'right';
        }
    }
    else game.player.velX = 0;

    // Jumping
    if (game.keys[' '] && !game.player.isJumping) {
        game.player.velY = JUMP_FORCE;
        game.player.isJumping = true;
    }

    // Attacking
    if (game.keys['x'] && !game.player.isAttacking) {
        game.player.isAttacking = true;
        attackWithMachete();
        setTimeout(() => {
            game.player.isAttacking = false;
        }, ATTACK_DURATION);
    }

    // Apply physics
    game.player.velY += GRAVITY;
    game.player.x += game.player.velX;
    game.player.y += game.player.velY;

    // Keep player in bounds
    if (game.player.x < 0) game.player.x = 0;
    if (game.player.x + game.player.width > game.ctx.canvas.width) {
        game.player.x = game.ctx.canvas.width - game.player.width;
    }
}

function checkCollisions() {
    game.player.isJumping = true;
    
    // Check floor collision first
    const floorY = game.ctx.canvas.height - game.player.height;
    if (game.player.y > floorY) {
        game.player.y = floorY;
        game.player.velY = 0;
        game.player.isJumping = false;
    }
    
    // Check block collisions
    for (const block of game.blocks) {
        if (game.player.x < block.x + block.width &&
            game.player.x + game.player.width > block.x &&
            game.player.y + game.player.height > block.y &&
            game.player.y < block.y + block.height) {
            
            // Ground collision
            if (game.player.velY > 0 && game.player.y + game.player.height - game.player.velY <= block.y) {
                game.player.y = block.y - game.player.height;
                game.player.velY = 0;
                game.player.isJumping = false;
            }
            // Ceiling collision
            else if (game.player.velY < 0 && game.player.y - game.player.velY >= block.y + block.height) {
                game.player.y = block.y + block.height;
                game.player.velY = 0;
            }
            // Wall collision
            else if (game.player.velX !== 0) {
                if (game.player.velX > 0) {
                    game.player.x = block.x - game.player.width;
                } else {
                    game.player.x = block.x + block.width;
                }
            }
        }
    }
}

function attackWithMachete() {
    const attackRange = 50;
    let attackBox;

    switch (game.player.attackDirection) {
        case 'up':
            attackBox = {
                x: game.player.x,
                y: game.player.y - attackRange,
                width: game.player.width,
                height: attackRange
            };
            break;
        case 'right':
            attackBox = {
                x: game.player.x + game.player.width,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
        case 'left':
            attackBox = {
                x: game.player.x - attackRange,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
    }

    game.blocks = game.blocks.filter(block => {
        return !(attackBox.x < block.x + block.width &&
                attackBox.x + attackBox.width > block.x &&
                attackBox.y < block.y + block.height &&
                attackBox.y + attackBox.height > block.y);
    });
}

const playerSpriteSVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 50">
    <!-- Body -->
    <rect x="10" y="20" width="10" height="20" fill="#3333ff"/>
    <!-- Head -->
    <circle cx="15" cy="15" r="8" fill="#ffccaa"/>
    <!-- Hair (spiky) -->
    <path d="M10 12 L15 5 L20 12" fill="#333333"/>
    <!-- Eyes -->
    <circle cx="13" cy="14" r="1" fill="#000"/>
    <circle cx="17" cy="14" r="1" fill="#000"/>
    <!-- Scowl -->
    <path d="M12 17 L18 17" stroke="#000" stroke-width="1"/>
    <!-- Arms -->
    <rect x="5" y="22" width="5" height="15" fill="#ffccaa"/>
    <rect x="20" y="22" width="5" height="15" fill="#ffccaa"/>
    <!-- Legs -->
    <rect x="10" y="40" width="4" height="10" fill="#000066"/>
    <rect x="16" y="40" width="4" height="10" fill="#000066"/>
    <!-- Machete -->
    <path d="M25 30 L35 30 L33 32 L25 32 Z" fill="#cccccc" class="machete"/>
</svg>`;

const playerSprite = new Image();
playerSprite.src = 'data:image/svg+xml;base64,' + btoa(playerSpriteSVG);

playerSprite.onload = function () {
    game.startRendering();
};

function render() {
    const ctx = game.ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw floor
    ctx.fillStyle = '#666';
    ctx.fillRect(0, ctx.canvas.height - 10, ctx.canvas.width, 10);

    // Draw blocks
    game.blocks.forEach(block => {
        ctx.fillStyle = block.fill || '#ff7f00';
        ctx.fillRect(block.x, block.y, block.width, block.height);
        
        // Draw block borders
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.strokeRect(block.x, block.y, block.width, block.height);
    });

    // Draw player sprite
    ctx.save();
    if (!game.player.facingRight) {
        ctx.translate(game.player.x + game.player.width, game.player.y);
        ctx.scale(-1, 1);
        ctx.drawImage(playerSprite, 0, 0, game.player.width, game.player.height);
    } else {
        ctx.drawImage(playerSprite, game.player.x, game.player.y, game.player.width, game.player.height);
    }
    ctx.restore();

    // Draw attack animation if attacking
    if (game.player.isAttacking) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        const attackRange = 50;
        
        switch (game.player.attackDirection) {
            case 'up':
                ctx.fillRect(game.player.x, game.player.y - attackRange, 
                           game.player.width, attackRange);
                break;
            case 'right':
                ctx.fillRect(game.player.x + game.player.width, game.player.y, 
                           attackRange, game.player.height);
                break;
            case 'left':
                ctx.fillRect(game.player.x - attackRange, game.player.y, 
                           attackRange, game.player.height);
                break;
        }
    }
}

// Update timer
function updateTimer() {
    if (game.isRunning) {
        game.currentTime = (Date.now() - game.startTime) / 1000;
        document.getElementById('timer').textContent = `Time: ${game.currentTime.toFixed(1)}s`;
    }
}

// Start game
function startGame() {
    game.isRunning = true;
    game.startTime = Date.now();
    document.getElementById('startButton').textContent = 'Reset Game';
    document.getElementById('startButton').onclick = resetGame;
    gameLoop();
}

// Reset game
function resetGame() {
    game.isRunning = false;
    if (game.currentTime < game.bestTime) {
        game.bestTime = game.currentTime;
        localStorage.setItem('bestTime', game.bestTime);
        document.getElementById('bestTime').textContent = `Best: ${game.bestTime.toFixed(1)}s`;
    }
    init();
    document.getElementById('startButton').textContent = 'Start Game';
    document.getElementById('startButton').onclick = startGame;
}

// Initialize the game when the page loads
window.addEventListener('load', () => {
    init();
    if (localStorage.getItem('bestTime')) {
        document.getElementById('bestTime').textContent = 
            `Best: ${parseFloat(localStorage.getItem('bestTime')).toFixed(1)}s`;
    }
});
    </script>
</body>
</html>

