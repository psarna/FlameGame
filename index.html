<!DOCTYPE html>
<html>
<head>
    <title>FlameGame</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #f5f5f5;
            min-height: 100vh;
        }
        #gameContainer {
            border: 2px solid #333;
            width: 95vw;
            height: 80vh;
            overflow: hidden;
            background: white;
            position: relative;
        }
        .controls {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 95vw;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 95vw;
        }
        .input-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #urlInput {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #ff5722;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            white-space: nowrap;
        }
        button:hover {
            background: #f4511e;
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        h1 {
            color: #ff5722;
            font-size: 2em;
            margin: 10px 0;
        }
        #stats {
            font-size: 1.2em;
            margin: 5px 0;
            font-weight: bold;
        }
        #stats span {
            margin: 0 10px;
        }
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 1000;
        }
        .control-btn {
            width: 50px;
            height: 50px;
            margin: 5px;
            font-size: 20px;
            touch-action: manipulation;
        }
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            .input-section {
                flex-wrap: wrap;
            }
            #urlInput {
                width: 100%;
            }
            h1 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <h1>FlameGame</h1>
    
    <div class="input-group">
        <div class="input-section">
            <label>File:</label>
            <input type="file" id="fileInput" accept=".svg">
        </div>
        <div class="input-section">
            <label>URL:</label>
            <input type="text" id="urlInput" placeholder="Enter SVG URL">
            <button id="loadUrlButton">Load</button>
        </div>
    </div>

    <div id="stats">
        <span id="timer">Time: 0.0s</span>
        <span id="bestTime">Best: --</span>
    </div>
    <div id="gameContainer"></div>
    <button id="startButton" disabled>Start Game</button>
    
    <div id="mobileControls">
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="jumpBtn">↑</button>
        <button class="control-btn" id="rightBtn">→</button>
        <button class="control-btn" id="attackBtn">X</button>
    </div>

    <div class="controls">
        <h3>Controls:</h3>
        <ul>
            <li>Desktop: Arrow Keys to Move, Space to Jump, X to Attack</li>
            <li>Mobile: On-screen buttons</li>
        </ul>
    </div>
    <script>

const game = {
    player: {
        x: 100,
        y: 100,
        width: 30,
        height: 50,
        velX: 0,
        velY: 0,
        isJumping: false,
        isAttacking: false,
        facingRight: true,
        attackDirection: 'right', // 'right', 'left', or 'up'
        attackTimeout: null
    },
    blocks: [],
    keys: {},
    isRunning: false,
    startTime: 0,
    currentTime: 0,
    bestTime: localStorage.getItem('bestTime') || Infinity,
    ctx: null,
    scale: 1,
    heightScale: 1,
};

const GRAVITY = 0.5;
const JUMP_FORCE = -16;
const MOVE_SPEED = 6;
const ATTACK_DURATION = 200;

// Default flame graph SVG
const defaultSVG = `
<svg width="1200" height="300">
    <rect x="10" y="250" width="1180" height="50" fill="#ff7f00"/>
    <rect x="100" y="200" width="400" height="50" fill="#ff9f00"/>
    <rect x="600" y="200" width="300" height="50" fill="#ffbf00"/>
    <rect x="150" y="150" width="200" height="50" fill="#ffdf00"/>
    <rect x="650" y="150" width="150" height="50" fill="#ffff00"/>
</svg>`;

// Initialize game
function init() {
    const container = document.getElementById('gameContainer');
    container.innerHTML = '';
    
    const canvas = document.createElement('canvas');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    container.appendChild(canvas);
    
    game.ctx = canvas.getContext('2d');
    setupEventListeners();
    
    // Load default flame graph
    loadSVGContent(defaultSVG);
    
    return game.ctx;
}

function loadSVGContent(svgContent) {
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
    const rects = Array.from(svgDoc.querySelectorAll('rect'));
    
    // Skip rects with width="100%"
    const validRects = rects.filter(rect => rect.getAttribute('width') !== '100%');
    
    const containerWidth = game.ctx.canvas.width;
    const containerHeight = game.ctx.canvas.height;
    
    // Find the boundaries of the SVG content
    let maxRight = 0;
    let maxBottom = 0;
    validRects.forEach(rect => {
        const right = parseFloat(rect.getAttribute('x')) + parseFloat(rect.getAttribute('width'));
        const bottom = parseFloat(rect.getAttribute('y')) + parseFloat(rect.getAttribute('height'));
        maxRight = Math.max(maxRight, right);
        maxBottom = Math.max(maxBottom, bottom);
    });
    console.log(maxRight, maxBottom);
    console.log(validRects)
    
    // Always scale to full width, then adjust height proportionally
    game.scale = containerWidth / maxRight;
    game.heightScale = containerHeight / maxBottom;
    
    // Scale and store blocks
    game.blocks = validRects.map(rect => {
        const x = parseFloat(rect.getAttribute('x'));
        const y = parseFloat(rect.getAttribute('y'));
        const width = parseFloat(rect.getAttribute('width'));
        const height = parseFloat(rect.getAttribute('height'));
        
        return {
            x: x * game.scale,
            y: y * game.heightScale,
            width: width * game.scale,
            height: height * game.heightScale,
            fill: rect.getAttribute('fill')
        };
    });
   
    document.getElementById('startButton').disabled = false;
    render();
    startGame();
}


// Load SVG from file or URL
async function loadSVG(source, isUrl = false) {
    try {
        let svgText;
        if (isUrl) {
            const response = await fetch(source);
            svgText = await response.text();
        } else {
            svgText = await source.text();
        }
        loadSVGContent(svgText);
    } catch (error) {
        console.error('Error loading SVG:', error);
    }
}

// Event Listeners
function setupEventListeners() {
    window.addEventListener('keydown', e => {
        game.keys[e.key] = true;
        if (e.key === ' ' || ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', e => {
        game.keys[e.key] = false;
    });
    
    document.getElementById('fileInput').addEventListener('change', e => {
        if (e.target.files[0]) {
            loadSVG(e.target.files[0]);
        }
    });
    
    document.getElementById('loadUrlButton').addEventListener('click', () => {
        const url = document.getElementById('urlInput').value;
        if (url) {
            loadSVG(url, true);
        }
    });
    
    document.getElementById('startButton').addEventListener('click', startGame);
}

// Game loop
function gameLoop() {
    if (!game.isRunning) return;

    updatePlayer();
    checkCollisions();
    render();
    updateTimer();
    
    requestAnimationFrame(gameLoop);
}

// Update player position and state
function updatePlayer() {
    // Horizontal movement
    if (game.keys['ArrowLeft']) {
        game.player.velX = -MOVE_SPEED;
        game.player.facingRight = false;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'left';
        }
    }
    else if (game.keys['ArrowRight']) {
        game.player.velX = MOVE_SPEED;
        game.player.facingRight = true;
        if (game.keys['ArrowUp']) {
            game.player.attackDirection = 'up';
        } else {
            game.player.attackDirection = 'right';
        }
    }
    else game.player.velX = 0;

    // Jumping
    if (game.keys[' '] && !game.player.isJumping) {
        game.player.velY = JUMP_FORCE;
        game.player.isJumping = true;
    }

    // Attacking
    if (game.keys['x'] && !game.player.isAttacking) {
        game.player.isAttacking = true;
        attackWithMachete();
        setTimeout(() => {
            game.player.isAttacking = false;
        }, ATTACK_DURATION);
    }

    // Apply physics
    game.player.velY += GRAVITY;
    game.player.x += game.player.velX;
    game.player.y += game.player.velY;

    // Keep player in bounds
    if (game.player.x < 0) game.player.x = 0;
    if (game.player.x + game.player.width > game.ctx.canvas.width) {
        game.player.x = game.ctx.canvas.width - game.player.width;
    }
}

function checkCollisions() {
    game.player.isJumping = true;
    
    // Check floor collision first
    const floorY = game.ctx.canvas.height - game.player.height;
    if (game.player.y > floorY) {
        game.player.y = floorY;
        game.player.velY = 0;
        game.player.isJumping = false;
    }
    
    // Check block collisions
    for (const block of game.blocks) {
        if (game.player.x < block.x + block.width &&
            game.player.x + game.player.width > block.x &&
            game.player.y + game.player.height > block.y &&
            game.player.y < block.y + block.height) {
            
            // Ground collision
            if (game.player.velY > 0 && game.player.y + game.player.height - game.player.velY <= block.y) {
                game.player.y = block.y - game.player.height;
                game.player.velY = 0;
                game.player.isJumping = false;
            }
            // Ceiling collision
            else if (game.player.velY < 0 && game.player.y - game.player.velY >= block.y + block.height) {
                game.player.y = block.y + block.height;
                game.player.velY = 0;
            }
            // Wall collision
            else if (game.player.velX !== 0) {
                if (game.player.velX > 0) {
                    game.player.x = block.x - game.player.width;
                } else {
                    game.player.x = block.x + block.width;
                }
            }
        }
    }
}

function attackWithMachete() {
    const attackRange = 50;
    let attackBox;

    switch (game.player.attackDirection) {
        case 'up':
            attackBox = {
                x: game.player.x,
                y: game.player.y - attackRange,
                width: game.player.width,
                height: attackRange
            };
            break;
        case 'right':
            attackBox = {
                x: game.player.x + game.player.width,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
        case 'left':
            attackBox = {
                x: game.player.x - attackRange,
                y: game.player.y,
                width: attackRange,
                height: game.player.height
            };
            break;
    }

    game.blocks = game.blocks.filter(block => {
        return !(attackBox.x < block.x + block.width &&
                attackBox.x + attackBox.width > block.x &&
                attackBox.y < block.y + block.height &&
                attackBox.y + attackBox.height > block.y);
    });
}

const playerSpriteSVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50">
    <!-- Head -->
    <circle cx="25" cy="12" r="10" fill="#ffccaa" stroke="#000" stroke-width="1"/>
    <!-- Facial Features -->
    <!-- Eye -->
    <circle cx="28" cy="12" r="2" fill="#000"/>
    <!-- Eyebrow -->
    <path d="M26 10 L30 10" stroke="#000" stroke-width="2"/>
    <!-- Mouth (Scowl) -->
    <path d="M26 14 Q28 16 30 14" stroke="#000" stroke-width="1" fill="none"/>
    <!-- Body -->
    <rect x="18" y="20" width="14" height="18" fill="#3333ff" stroke="#000" stroke-width="1"/>
    <!-- Tactical Vest -->
    <rect x="18" y="25" width="14" height="5" fill="#222222" stroke="#000" stroke-width="1"/>
    <rect x="20" y="22" width="10" height="3" fill="#444444" stroke="#000" stroke-width="1"/>
    <!-- Arms -->
    <rect x="12" y="22" width="6" height="12" fill="#ffccaa" stroke="#000" stroke-width="1"/>
    <rect x="32" y="22" width="6" height="12" fill="#ffccaa" stroke="#000" stroke-width="1"/>
    <!-- Arm Details -->
    <rect x="12" y="26" width="6" height="4" fill="#666666" stroke="#000" stroke-width="1"/>
    <rect x="32" y="26" width="6" height="4" fill="#666666" stroke="#000" stroke-width="1"/>
    <!-- Machete -->
    <path d="M35 35 L50 33 L48 36 L35 38 Z" fill="#cccccc" stroke="#000" stroke-width="1"/>
    <!-- Machete Handle -->
    <rect x="34" y="34" width="3" height="6" fill="#000" stroke="#000" stroke-width="1"/>
    <!-- Legs -->
    <rect x="20" y="38" width="5" height="12" fill="#444444" stroke="#000" stroke-width="1"/>
    <rect x="25" y="38" width="5" height="12" fill="#444444" stroke="#000" stroke-width="1"/>
    <!-- Boots -->
    <rect x="20" y="48" width="5" height="2" fill="#222222" stroke="#000" stroke-width="1"/>
    <rect x="25" y="48" width="5" height="2" fill="#222222" stroke="#000" stroke-width="1"/>
</svg>
`;

const playerSprite = new Image();
playerSprite.src = 'data:image/svg+xml;base64,' + btoa(playerSpriteSVG);

playerSprite.onload = function () {
    game.startRendering();
};

function render() {
    const ctx = game.ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw background
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw floor
    ctx.fillStyle = '#666';
    ctx.fillRect(0, ctx.canvas.height - 10, ctx.canvas.width, 10);

    // Draw blocks
    game.blocks.forEach(block => {
        ctx.fillStyle = block.fill || '#ff7f00';
        ctx.fillRect(block.x, block.y, block.width, block.height);
        
        // Draw block borders
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.strokeRect(block.x, block.y, block.width, block.height);
    });

    // Draw player sprite
    ctx.save();
    if (!game.player.facingRight) {
        ctx.translate(game.player.x + game.player.width, game.player.y);
        ctx.scale(-1, 1);
        ctx.drawImage(playerSprite, 0, 0, game.player.width, game.player.height);
    } else {
        ctx.drawImage(playerSprite, game.player.x, game.player.y, game.player.width, game.player.height);
    }
    ctx.restore();

    // Draw attack animation if attacking
    if (game.player.isAttacking) {
        const attackRange = 50;

        ctx.save();
        ctx.translate(game.player.x + game.player.width / 2, game.player.y + game.player.height / 2);
        
        // Determine direction of attack
        let rotation = 0;
        switch (game.player.attackDirection) {
            case 'up':
                rotation = -Math.PI / 2; // Rotate slash upward
                break;
            case 'right':
                rotation = 0; // Default slash direction
                break;
            case 'left':
                rotation = Math.PI; // Rotate slash to the left
                break;
            case 'down':
                rotation = Math.PI / 2; // Rotate slash downward
                break;
        }
        ctx.rotate(rotation);

        // Draw the comic-style slash
        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)'; // Slash glow
        ctx.beginPath();
        ctx.moveTo(-attackRange, 0);
        ctx.quadraticCurveTo(0, -attackRange, attackRange, 0);
        ctx.quadraticCurveTo(0, attackRange, -attackRange, 0);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = '#ff0000'; // Slash edge
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-attackRange, 0);
        ctx.quadraticCurveTo(0, -attackRange, attackRange, 0);
        ctx.stroke();

        // Add speed lines
        ctx.strokeStyle = '#ffcccc';
        ctx.lineWidth = 2;
        for (let i = -attackRange / 2; i <= attackRange / 2; i += attackRange / 4) {
            ctx.beginPath();
            ctx.moveTo(i, -10);
            ctx.lineTo(i + 10, -20);
            ctx.stroke();
        }

        ctx.restore();
    }
}

// Update timer
function updateTimer() {
    if (game.isRunning) {
        game.currentTime = (Date.now() - game.startTime) / 1000;
        document.getElementById('timer').textContent = `Time: ${game.currentTime.toFixed(1)}s`;
    }
}

// Start game
function startGame() {
    game.isRunning = true;
    game.startTime = Date.now();

    // Reset player position
    game.player.x = 50;
    game.player.y = 0;
    game.player.velX = 0;
    game.player.velY = 0;

    document.getElementById('startButton').textContent = 'Reset Game';
    document.getElementById('startButton').onclick = resetGame;
    gameLoop();
}

// Reset game
function resetGame() {
    game.isRunning = false;
    if (game.currentTime < game.bestTime) {
        game.bestTime = game.currentTime;
        localStorage.setItem('bestTime', game.bestTime);
        document.getElementById('bestTime').textContent = `Best: ${game.bestTime.toFixed(1)}s`;
    }
    init();
    document.getElementById('startButton').textContent = 'Start Game';
    document.getElementById('startButton').onclick = startGame;
}

// Initialize the game when the page loads
window.addEventListener('load', () => {
    init();
    if (localStorage.getItem('bestTime')) {
        document.getElementById('bestTime').textContent = 
            `Best: ${parseFloat(localStorage.getItem('bestTime')).toFixed(1)}s`;
    }
});
    </script>
</body>
</html>

